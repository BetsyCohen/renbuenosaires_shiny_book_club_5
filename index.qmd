---
format:
  revealjs: 
    theme: [default, styles.scss]
    width: 1280
    height: 720
    include-after-body: 
      - "all-the-js-code.html"
    revealjs-plugins:
      - codewindow
echo: false
code-line-numbers: false
footer: "Realizado con el <a href='https://github.com/EmilHvitfeldt/talk-socalrug-hackathon-feature-engineering' target='_blank'>template de emilhvitfeldt</a> para el <a href='https://github.com/RLadies-BA/mastering-shiny' target='_blank'>Club de lectura Mastering Shiny</a>"
editor: 
  markdown: 
    wrap: 72
---

## User feedback {.theme-title .center}

### Mastering Shiny Book Club

Betsy Cohen & Ariana Bardauil

## Objetivos de este encuentro

::: {.speech .pink}
![](assets/cat-theme/profile-01.svg) Recapitular encuentros anteriores
:::

:::: fragment
::: {.speech .purple .right}
Cap√≠tulo 8: User feedback ![](assets/cat-theme/profile-02.svg)
:::
::::

#  {.theme-section2}

::: {.r-fit-text style="transform: translateY(-15rem);"}
¬øQu√© vimos en los encuentros anteriores?
:::

# Encuentro 1 {.theme-section3}

Basic APP & Basic UI

## Cap√≠tulos 1 y 2: Basic APP & Basic UI

:::: fragment
::: r-fit-text
Construimos nuestra

[primera aplicaci√≥n]{.pink-shadow}

en [shiny]{.blue-shadow}
:::
::::

## Estructura b√°sica

<br>

![](assets/cat-theme/head-01.svg){.absolute bottom="0" right="0"
width="150" height="150"}

::::::: columns
:::: column
::: codewindow
``` r
library(shiny)

ui <- fluidPage(
  textInput("name", "¬øC√≥mo te llam√°s?"),
  textOutput("greeting")
)

server <- function(input, output, session) {
  output$greeting <- renderText({
    paste0("Hola ", input$name, "!")
  })
}

shinyApp(ui, server)
```
:::
::::

:::: column
::: incremental
-   **ui** define la interfaz de usuario.
-   **server** define la l√≥gica del servidor (c√≥mo responde la app).
-   **shinyApp(ui, server)** renderiza la app.
:::
::::
:::::::

## Estructura b√°sica

![](assets/cat-theme/head-07.svg){.absolute top="-50" right="300"
width="150" height="150"}

<br>

![](imagenes/1.01.basic_app.png){fig-align="center" width="913"}

<!-- ## UI basica -->

<!-- ![](assets/cat-theme/head-24.svg){.absolute top="-50" right="300"} -->

<!-- ::: {.spacer style="height:70%;"} -->

<!-- [fluidPage()]{.brown-text} organiza los componentes en una p√°gina -->

<!-- adaptable. -->

<!-- Vimos algunas [entradas o inputs]{.pink-text} como `textInput()` (texto -->

<!-- libre), `numericInput()` (n√∫meros), `actionButton()` (botones) y -->

<!-- `sliderInput()`. -->

<!-- Y, [salidas (outputs)]{.pink-text} como `textOutput()` que permiten la -->

<!-- l√≥gica reactiva desde el `server()` usando `render...` o `eventReactive` -->

<!-- (para los botones). -->

<!-- ::: -->

# Encuentro 2 {.theme-section4}

Basic reactivity

## Basic reactivity

![](assets/cat-theme/head-30.svg){.absolute top="-50" right="300"
width="120" height="120"} ![](assets/cat-theme/head-31.svg){.absolute
top="-50" right="120" width="150" height="120"}

![](imagenes/2.01.reactividad.png){fig-align="center" width="723"}

![](imagenes/2.02.users.png){fig-align="center" width="516"}

## Programaci√≥n declarativa

![](assets/cat-theme/head-07.svg){.absolute top="-50" right="300"
width="150" height="150"} ![](assets/cat-theme/head-08.svg){.absolute
top="-50" right="150" width="150" height="150"}

<br>

Shiny usa [programaci√≥n declarativa]{.pink-text}

> No le indicamos qu√© hacer sino qu√© queremos lograr.

[Son aplicaciones perezosas]{.pink-text}: solo actualizan los outputs
visibles, y solo cuando es necesario.

::::: columns
::: {.column width="20%"}
![](https://cdn.pixabay.com/animation/2023/04/28/18/34/18-34-10-554_512.gif){fig-align="center"
width="128" height="109"}
:::

::: {.column width="80%"}
Si no est√° vinculado a una salida visible el [c√≥digo puede no ejecutarse
nunca]{.brown-text}
:::
:::::

# Encuentro 3 {.theme-section5}

Workflow

## Control de flujo & debuggeo

![](assets/cat-theme/turso-03.svg){.absolute top="150" right="100"
width="450" height="450"}

¬øQu√© puedo usar para saber [qu√© le pasa a mi app]{.blue-text} ?

:::::::: columns
:::::: {.column width="50%"}
::: codewindow
``` r
print() cat()
```
:::

::: codewindow
``` r
# Abre una app interactiva
eventReactive(input$go, {
  browser() 
  input$a + input$b
})
```
:::

::: codewindow
``` r
# Al principio del script
reactlog::reactlog_enable()
# Luego de ejecutar la APP y cerrarla:
shiny::reactlogShow()
```
:::
::::::

::: {.column width="50%"}
:::
::::::::

# Encuentro 4 {.theme-section1}

Layout, themes, HTML

## Layouts (dise√±os de p√°gina)

![](assets/cat-theme/turso-02.svg){.absolute top="50" right="50"
width="450" height="450"}

::: {.spacer style="height:70%;"}
[P√°gina √∫nica]{.brown-text}

`fluidPage()`, `fixedPage()` ,`fillPag()` (p√°gina)

`sidebarLayout()` , `fluidRow()` , `column()` (dise√±o)

[Varias p√°ginas]{.pink-text}

`navbarPage()` (p√°gina)

`tabsetPanel()`, `tabPanel()` , `navlistPanel()` ,`navbarMenu()`
(dise√±o)
:::

## Aplicaci√≥n de estilos

:::::::: columns
::::: {.column width="50%"}
**HTML**

::: codewindow
``` r
<span style="color:hotpink;">texto de prueba</span>
```
:::

**CSS**

::: codewindow
``` r
.pink-text {
  color: darken($theme-pink, 10%);
  font-weight: bold;
}
```
:::

[texto de prueba]{.pink-text}
:::::

:::: {.column width="50%"}
**THEME**

::: codewindow
``` r
library(shiny)
library(bslib)

ui <- fluidPage(
  theme = bs_theme(bootswatch = "minty"),
  h2("App con tema Minty"),
  sliderInput("x", "Eleg√≠ un n√∫mero", 1, 100, 50),
  textOutput("valor")
)

server <- function(input, output, session) {
  output$valor <- renderText({
    paste("N√∫mero:", input$x)
  })
}
```
:::
::::
::::::::

# Encuentro 5 {.theme-section6}

[HOY HOY HOY HOY HOY]{.brown-text}

#  {.theme-section7}

::: {.r-fit-text style="transform: translateY(-15rem);"}
[User feedback]{.brown-shadow}
:::

## El UX no son los padres

![](assets/cat-theme/head-14.svg){.absolute top="400" left="300"
width="150" height="150"} ![](assets/cat-theme/head-15.svg){.absolute
top="400" left="50" width="150" height="150"}
![](assets/cat-theme/head-16.svg){.absolute top="200" left="300"
width="150" height="150"} ![](assets/cat-theme/head-17.svg){.absolute
top="200" left="50" width="150" height="150"}

::: {.spacer style="height:70%; text-align: right;"}
Experiencia de [usuario]{.purple-text}

[Interactuar]{.blue-text} de manera [visual]{.pink-text}

Pedagog√≠a refuerzo con [est√≠mulo visual]{.brown-text}
:::

::: notes
Un concepto central en nuestra app es la **experiencia de usabilidad** o
UX

No solo se trata de que todo se vea bonito (como vimos en el capitulo de
Themes) sino tambi√©n de que interactuar o dar un feedback de manera
visual ante las diferentes situaciones de interacci√≥n que plantea
nuestra app.

En shinny de manera autom√°tica, pero hay otros que podemos agregar que
refuerzan este est√≠mulo
:::

## Tipos de feedback

![](assets/cat-theme/head-12.svg){.absolute bottom="0" left="0"
width="150" height="150"}

En el cap√≠tulo se recorren 4 posibles formas de feedback usando el ayud√≠n
de `shinyFeedback` y `waiter`.

:::::: columns
:::: {.column width="70%"}
::: incremental
-   üõëÔ∏è Validaci√≥n
-   ‚ö† Notificaci√≥n
-   ‚åõ Barras de progreso
-   üëå Di√°logos de confirmaci√≥n
-   üîô Botones de deshacer
:::
::::

::: {.column width="30%"}
![](imagenes/shinyfeedback_waiter_hexs.png)
:::
::::::

## Validar una entrada {.smaller}

![](assets/cat-theme/head-10.svg){.absolute bottom="0" right="0"
width="150" height="150"}

::: notes
Pensar en c√≥mo el usuario podr√≠a usar mal tu aplicaci√≥n te permite
proporcionar mensajes informativos en la interfaz de usuario, en lugar
de permitir que los errores se filtren en el c√≥digo de R y generen
errores no informativos.

Un primer paso es validar el tipo de entrada cosa que podemos hacer con
el paquete shinyFeedback
:::

:::::: columns
::: column
```{r}
#| code-line-numbers: "4,12-15"
#| eval: false
#| echo: true

library(shiny)

ui <- fluidPage(
  shinyFeedback::useShinyFeedback(),
  numericInput("n", "n", value = 10),
  textOutput("half")
)

server <- function(input, output, session) {
  half <- reactive({
    even <- input$n %% 2 == 0
    shinyFeedback::feedbackWarning(
      inputId = "n", 
      show = !even,
      text = "Por favor pone un n√∫mero par")
    input$n / 2    
  })
  
  output$half <- renderText(half())
}

shinyApp(ui, server)

```
:::

:::: column
::: incremental
-   Agregamos `useShinyFeedback()` en el ui.
-   En el usamos alguna de las funciones de retroalimentaci√≥n
    `feedback()`, `feedbackWarning()`, `feedbackDanger()`y
    `feedbackSuccess()`
-   Todas tienen [tres argumentos obligatorios]{.blue-text}
    (**inputId**, **show**, **text**) y de manera optativa podemos
    personalizar con: [color]{.purple-text} y [icon]{.purple-text}
:::
::::
::::::

## Validar una entrada

![](assets/cat-theme/turso-01.svg){.absolute top="280" right="100"
width="300" height="300"}

:::::: columns
:::: column
::: codewindow
``` r
library(shiny)

ui <- fluidPage(
  shinyFeedback::useShinyFeedback(),
  numericInput("n", "n", value = 10),
  textOutput("half")
)

server <- function(input, output, session) {
  half <- reactive({
    even <- input$n %% 2 == 0
    shinyFeedback::feedbackWarning("n", !even, "Por favor pone un n√∫mero par")
    input$n / 2    
  })
  
  output$half <- renderText(half())
}

shinyApp(ui, server)
```
:::
::::

::: column
![](imagenes/5.01.shinyfeedback_sin_rec.png)
:::
::::::

## Pausar la ejecuci√≥n bajo requisitos {.smaller}

![](assets/cat-theme/turso-04.svg){.absolute top="330" right="100"
width="300" height="300"}

¬øC√≥mo **pausamos la ejecuci√≥n** para que no ocurra nada hasta que se
cumplan ciertas condiciones en nuestro `reactive{}`? [La funci√≥n `req()`
nos permite agregar requisitos para la ejecucci√≥n dentro del
server]{.fragment .highlight-purple fragment-index="1"}. Por ej. ponemos
como requisito que *no muestre el resultado si no es un n¬∞ par*

::::: columns
::: column
```{r}
#| code-line-numbers: "16"
#| eval: false
#| echo: true

library(shiny)

ui <- fluidPage(
  shinyFeedback::useShinyFeedback(),
  numericInput("n", "n", value = 10),
  textOutput("half")
)

server <- function(input, output, session) {
  half <- reactive({
    even <- input$n %% 2 == 0
    shinyFeedback::feedbackWarning(
      inputId = "n", 
      show = !even,
      text = "Por favor pone un n√∫mero par")
    req(even)
    input$n / 2    
  })
  
  output$half <- renderText(half())
}

shinyApp(ui, server)

```
:::

::: column
![](imagenes/5.02.shinyfeedback_con_rec.png)
:::
:::::

## Pausar la ejecuci√≥n bajo requisitos {.smaller}

![](assets/cat-theme/head-21.svg){.absolute bottom="150" right="250"
width="150" height="150"}

A veces queremos *freezar* m√°s de una condici√≥n y esperar a que el
usuario termine de hacer algo. Por ej. en este caso necesitamos que
termine de elegir el idioma (`selectInput()`) y ponga sunombre
(`textInput()`) para que se ejecute el **greetings** en el `paste0()`

:::::: columns
:::: column
::: codewindow
``` r
ui <- fluidPage(
  selectInput("language", "Language", choices = c("", "English", "Maori")),
  textInput("name", "Name"),
  textOutput("greeting")
)

server <- function(input, output, session) {
  greetings <- c(
    English = "Hello", 
    Spanish = "Hola"
  )
  output$greeting <- renderText({
    req(input$language, input$name)
    paste0(greetings[[input$language]], " ", input$name, "!")
  })
}
```
:::
::::

::: column
![](imagenes/5.03.rec_multiple.png)
:::
::::::

::: callout-note
### req() como condici√≥n especial

Se puede usar `req()` con su propia declaraci√≥n l√≥gica. Por ejemplo:
**req(input\$a \> 0)** permitir√° que el c√°lculo contin√∫e cuando sea
mayor que 0.
:::

## Combinando `req()` y `shinyFeedback` {.smaller}

Adem√°s, podemos combinar **ambas cosas**. En este caso, queremos
continuar con el c√°lculo si el usuario ha ingresado un valor, por lo que
con `req()` chequeamos si el nombre existe y en caso de que **NO** env√≠a
un **warning** avisando.

:::::: columns
:::: column
::: codewindow
``` r
server <- function(input, output, session) {
  data <- reactive({
    req(input$dataset)
    
    exists <- exists(input$dataset, "package:datasets")
    shinyFeedback::feedbackDanger("dataset", !exists, "Dataset desconocido")
    req(exists, cancelOutput = TRUE)

    get(input$dataset, "package:datasets")
  })
  
  output$data <- renderTable({
    head(data())
  })
}
```
:::
::::

::: column
![](imagenes/5.04.validacion_junto_con_rec.png)
:::
::::::

~(\*)¬†Ejemplo¬†retomado¬†del¬†cap√≠tulo¬†1~

## Validar multiples entradas y salidas con `validate()` {.smaller}

![](assets/cat-theme/head-02.svg){.absolute bottom="50" right="370"
width="150" height="150"} ![](assets/cat-theme/head-03.svg){.absolute
bottom="50" right="220" width="150" height="150"}
![](assets/cat-theme/head-04.svg){.absolute bottom="50" right="70"
width="150" height="150"}

La funci√≥n integrada de shiny `validate()` nos va a permitir [controlar
m√∫ltiples entradas]{.pink-text} **y** tirar el [mensaje]{.blue-text}.

El siguiente c√≥digo muestra un ejemplo sencillo donde [no
queremos]{.brown-text} registrar ni calcular la ra√≠z cuadrada de valores
negativos en x.

:::::: columns
:::: column
::: codewindow
``` r
ui <- fluidPage(
  numericInput("x", "x", value = 0),
  selectInput("trans", "transformation", 
    choices = c("square", "log", "square-root")
  ),
  textOutput("out")
)

server <- function(input, output, session) {
  output$out <- renderText({
    if (input$x < 0 && input$trans %in% c("log", "square-root")) {
      validate("El valor que elegiste para tu x no admite ser negativo para aplicarle este c√°lculo")
    }
    
    switch(input$trans,
      square = input$x ^ 2,
      "square-root" = sqrt(input$x),
      log = log(input$x)
    )
  })
}
```
:::
::::

::: column
![](imagenes/5.05.validacion_con_validate.png)
:::
::::::

## Cual ser√≠a la diferencia entre `validate()` y `req()` {.smaller}

![](assets/cat-theme/head-02.svg){.absolute bottom="50" right="370"
width="150" height="150"} ![](assets/cat-theme/head-03.svg){.absolute
bottom="50" right="220" width="150" height="150"}
![](assets/cat-theme/head-04.svg){.absolute bottom="50" right="70"
width="150" height="150"} ![](assets/cat-theme/head-24.svg){.absolute
bottom="50" right="530" width="150" height="150"}
![](assets/cat-theme/head-23.svg){.absolute bottom="50" right="670"
width="150" height="150"} ![](assets/cat-theme/head-22.svg){.absolute
bottom="50" right="830" width="150" height="150"}
![](assets/cat-theme/head-21.svg){.absolute bottom="50" right="970"
width="150" height="150"} ![](assets/cat-theme/head-20.svg){.absolute
bottom="50" right="1100" width="150" height="150"} <br>

| Funci√≥n | ¬øQu√© hace? | ¬øD√≥nde se usa? | ¬øQu√© muestra si falla? |
|------------------|-------------------|------------------|------------------|
| `req()` | Verifica que un valor exista o cumpla una condici√≥n m√≠nima | Cualquier parte del servidor | **Nada** (el output queda en blanco) |
| `validate()` | Verifica una condici√≥n l√≥gica y **muestra un mensaje de error personalizado** | Solo dentro de `render*()` outputs | El **mensaje de error** que le pongas |

## Notificaciones

Las [notificaciones]{.pink-text} aparecen apiladas en la parte
**inferior derecha de la app.**

`showNotification()` tiene los siguientes tipos de notificaci√≥n:

::: incremental
-   [transitoria]{.blue-text}: desaparece despu√©s de un per√≠odo de
    tiempo fijo.
-   [del proceso]{.brown-text}: aparece cuando se inicia un proceso y al
    finalizar desaparece.
-   [progresivas]{.purple-text}: actualiza una sola notificaci√≥n con
    actualizaciones progresivas
:::

## Notificaci√≥n [transitoria]{.blue-text} {.smaller}

![](assets/cat-theme/head-06.svg){.absolute top="0" right="0"
width="120" height="120"}

la forma n√°s sencilla es
`showNotification("el mensaje que queres mostrar")`

[duration]{.pink-text} permite estipular una duraci√≥n, la predeterminada
es 5 seg.

se puede configurar el argumento type para [tunearlo]{.blue-text} con un
css para *"message"*, *"warning"* o *"error"*

:::::: columns
:::: column
::: codewindow
``` r
library(shiny)

ui <- fluidPage(
  textInput("nombre", "Nombre"),
  actionButton("enviar", "Enviar")
)

server <- function(input, output, session) {
  observeEvent(input$enviar, {
    if (input$nombre == "") {
      showNotification("Por favor ingres√° un nombre", type = "error")
    } else {
      showNotification("Formulario enviado correctamente", type = "message")
    }
  })
}

shinyApp(ui, server)
```
:::
::::

::: column
![](imagenes/5.06.Notificacion_transitoria.png)
:::
::::::

## Notificaci√≥n [del proceso]{.brown-text}

:::::: columns
:::: column
::: codewindow
``` r
library(shiny)

ui <- fluidPage(
  actionButton("procesar", "Procesar datos")
)

server <- function(input, output, session) {
  observeEvent(input$procesar, {
    # Mostrar notificaci√≥n persistente mientras se procesa
    id <- showNotification("Procesando datos...", duration = NULL, closeButton = FALSE, type = "message")
    
    # Simular un proceso lento
    Sys.sleep(3)
    
    # Eliminar la notificaci√≥n al terminar
    removeNotification(id)
    
    # Mostrar notificaci√≥n de √©xito que desaparece sola
    showNotification("¬°Datos procesados correctamente!", type = "message")
  })
}

shinyApp(ui, server)
```
:::
::::

::: column
![](imagenes/5.06.Notificacion_proceso.gif)
:::
::::::

## Notificaci√≥n de actualizaci√≥n [progresivas]{.purple-text} {.smaller}

Para **simular una notificaci√≥n progresiva** en lugar de mostrar notis
distintas (una debajo de la otra como si fuera un ü•™) podemos jugar con
el par√°metro **`id`** de `showNotification()` de forma que va a aparecer
como si *estuviera actualizando el texto de la misma notificaci√≥n.*

üëâüèªEl par√°metro `id` sirve para ir concatenando esta simulaci√≥n

:::::: columns
:::: column
::: codewindow
``` r
library(shiny)

ui <- fluidPage(
  actionButton("start", "Iniciar carga de datos"),
  tableOutput("data")
)

server <- function(input, output, session) {
  notify <- function(msg, id = NULL) {
    showNotification(msg, id = id, duration = NULL, closeButton = FALSE)
  }
  
  data <- eventReactive(input$start, { 
    id <- notify("Leyendo datos...")
    on.exit(removeNotification(id), add = TRUE)
    Sys.sleep(1)
    
    notify("Reticulando splines...", id = id)
    Sys.sleep(1)
    
    notify("Agrupando llamas...", id = id)
    Sys.sleep(1)
    
    notify("Ortogonalizando matrices...", id = id)
    Sys.sleep(1)
    
    mtcars  # dataset incorporado en R
  })
  
  output$data <- renderTable(head(data()))
}

shinyApp(ui, server)
```
:::
::::

::: column
![](imagenes/5.06.Notificacion_progresiva.gif)
:::
::::::

## Barras de progreso {.smaller}

La sensaci√≥n de paso del tiempo es muy importante desde el punto de
vista del UX. Lo que estamos buscando con este tipo de elementos es:

:::: fragment
::: {.speech .pink}
![](assets/cat-theme/profile-01.svg){width="70"} **Proveer distracci√≥n**
con im√°genes, textos (con un dato curioso por ej.) o sonidos.
:::
::::

:::: fragment
::: {.speech .purple}
![](assets/cat-theme/profile-02.svg){width="70"} Brindar una
**explicaci√≥n** de por qu√© estas esperando
:::
::::

:::: fragment
::: {.speech .blue}
![](assets/cat-theme/profile-03.svg){width="70"} Dar **certeza**
respecto de cu√°nto tiempo llevar√°.
:::
::::

## Barras de progreso

![](assets/cat-theme/turso-01.svg){.absolute top="200" right="100"
width="220" height="220"}

:::: {.spacer style="height:70%;"}
En el libro vemos dos soluciones: una [nativa de shiny]{.blue-text} y
otra con el paquete `waiter{}`

Adicionalmente existe la librer√≠a [{progress}]{.purple-text}

::: callout-important
Para ambos casos hay que dividir la tarea principal en un n√∫mero
determinado de partes peque√±as que tomen aproximadamente el mismo
tiempo.
:::
::::

## Barras de progreso con shiny {.smaller}

Para crear una barra de progreso con Shiny, necesitas usar
`withProgress()` e `incProgress()`

El primer argumento de `incProgress()` es la [**cantidad que se
incrementar√°**]{.pink-text} en la barra de progreso. Por defecto, [la
barra de progreso empieza en 0 y termina en 1, por lo que el incremento
en 1 dividido por el n√∫mero de pasos garantizar√° que la barra de
progreso est√© completa al final del bucle.]{.fragment .highlight-blue
fragment-index="1"}

:::::: columns
:::: column
::: codewindow
``` r
ui <- fluidPage(
  numericInput("steps", "How many steps?", 10),
  actionButton("go", "go"),
  textOutput("result")
)

server <- function(input, output, session) {
  data <- eventReactive(input$go, {
    withProgress(message = "Computing random number", {
      for (i in seq_len(input$steps)) {
        Sys.sleep(0.5)
        incProgress(1 / input$steps)
      }
      runif(1)
    })
  })
  
  output$result <- renderText(round(data(), 2))
}
```
:::
::::

::: column
![](imagenes/5.07.Barra_con_shiny.gif){width="563"}
:::
::::::

::: notes
El primer argumento de incProgress()es la cantidad que se incrementar√°
en la barra de progreso. Por defecto, la barra de progreso empieza en 0
y termina en 1, por lo que el incremento en 1 dividido por el n√∫mero de
pasos garantizar√° que la barra de progreso est√© completa al final del
bucle.
:::

## El paquete waiter

![](assets/cat-theme/turso-02.svg){.absolute top="200" right="20"
width="450" height="450"}

El paquete `{waiter}` tambien nos permite mostrar barras de progreso con
waitress y hostess

La acci√≥n se define en 4 pasos

::: incremental
1.  [Poner]{.blue-text} `useWaiter` en cualquier parte de tu UI.

2.  [Crear]{.brown-text} el waiter

3.  [Mostrar]{.pink-text} el waiter

4.  [Ocultar]{.purple-text} el waiter
:::

## Spinners con `{waiter}` {.smaller}

`waiter()` es ideal para [spinners]{.blue-text}. Permite hacer
**barras** m√°s *chulas* y editar el html o agregar gifs

üëâüèª Por ej. Ac√° usamos un `spin_flower()` para que muestre una üåªmientras
carga el gr√°fico

:::::: columns
:::: column
::: codewindow
``` r
library(shiny)
library(waiter)

ui <- fluidPage(
  use_waiter(),  # Necesario para que waiter funcione
  autoWaiter(
    color = "white",
    html = tagList(
      spin_flowers(),
      br(), br(),
      tagAppendAttributes(
        style = "color:black",
        p("Cargando tus gr√°ficos")
      )
    )
  ),
  actionButton("trigger", "Render"),
  plotOutput("plot"),
  plotOutput("plot2")
)

server <- function(input, output) {
  
  observeEvent(input$trigger, {
    
    output$plot <- renderPlot({
      Sys.sleep(3)
      plot(cars)
    })
    
    output$plot2 <- renderPlot({
      Sys.sleep(5)
      plot(runif(100))
    })
    
  })
  
}

shinyApp(ui, server)
```
:::
::::

::: column
![](imagenes/5.08.Spiner_con_waiter.gif)
:::
::::::

## Barras con `waitress` {.smaller}

Por default waiter muestra un spinner (y podemos elegir entre m√°s de 100
modelos!) pero tambi√©n podemos hacer [barras]{.blue-text} usando la
funcion `useWaitress()`en el UI definiendo el waitress con
`Waitress$new`. Dentro de `Waitress$new` nos permite setear a que
elemento le vamos a aplicar la barra (`selector`), as√≠ como un `theme`,
`max` y `min` de la barra.

:::::: columns
:::: column
::: codewindow
``` r
library(shiny)
library(waiter)

ui <- navbarPage("Waitress aplicado al nav",
                 tabPanel("home",
                          useWaitress(color = "#7F7FFF"),
                          actionButton("go", "Generar gr√°fico"),
                          plotOutput("plot")
                 )
)

server <- function(input, output, session) {
  
  waitress <- Waitress$new( # Creamos el objeto waitress una sola vez 
    selector = "nav", 
    theme = "overlay-percent", 
    min = 0, 
    max = 10
  )
  
  observeEvent(input$go, {
    
    waitress$start()  # Muestra el loader
    
    output$plot <- renderPlot({
      for (i in 1:10) {
        waitress$inc(1)  # Incrementa 10%
        Sys.sleep(0.5)
      }
      waitress$close()  # Oculta el loader cuando termina
      hist(runif(100))
    })
    
  })
}

shinyApp(ui, server)
```
:::
::::

::: column
![](imagenes/5.08.Barra_con_waittress.gif)
:::
::::::

## Spinners con `shinycssloaders` {.smaller}

Otra forma muy pr√°ctica de hacer spinners es con el paquete
`{shinycssloaders}`. Simplemente agregamos
`shinycssloaders::withSpinner()` para envolver el output que queremos
que *"spinee"* automaticamente y asereje!

:::::: columns
:::: column
::: codewindow
``` r
library(shinycssloaders)

ui <- fluidPage(
  actionButton("go", "go"),
  withSpinner(plotOutput("plot")),
)
server <- function(input, output, session) {
  data <- eventReactive(input$go, {
    Sys.sleep(3)
    data.frame(x = runif(50), y = runif(50))
  })
  
  output$plot <- renderPlot(plot(data()), res = 96)
}
```
:::
::::

::: column
![](imagenes/5.09.Spiner_con_shinycssloaders.gif)
:::
::::::

## Dudo luego `alt`+`cntrl`+`supr`: confirmaci√≥n y arrepentimientos {.smaller}

:::: fragment
::: {.speech .pink}
![](assets/cat-theme/profile-01.svg) Pedir la confirmaci√≥n explicita
:::
::::

:::: fragment
::: {.speech .purple}
![](assets/cat-theme/profile-02.svg) Bot√≥n deshacer
:::
::::

:::: fragment
::: {.speech .blue}
![](assets/cat-theme/profile-03.svg) Cesto de reciclaje
:::
::::

::: notes
A veces, una acci√≥n es potencialmente peligrosa, y conviene asegurarse
de que el usuario realmente quiera realizarla o darle la posibilidad de
desistir antes de que sea demasiado tarde. En este capitulo se muestran
tres t√©cnicas de b√°sicas.
:::

## Confirmaci√≥n explicita {.smaller}

![](assets/cat-theme/head-21.svg){.absolute bottom="50" right="50"
width="150" height="150"} ![](assets/cat-theme/head-21.svg){.absolute
bottom="50" right="180" width="150" height="150"}
![](assets/cat-theme/head-21.svg){.absolute bottom="50" right="310"
width="150" height="150"} ![](assets/cat-theme/head-21.svg){.absolute
bottom="50" right="440" width="150" height="150"}

Con la funci√≥n `modalDialog()` es como una especie de *aduana* en la que
creamos un nuevo modo de interacci√≥n: [no se puede interactuar con la
app principal hasta que no se haya procesado el di√°logo]{.purple-text}.
Lo definimos **fuera del server** y despu√©s lo usamos de manera din√°mica
como *eventos condicionales* **dentro** del mismo

:::::: columns
:::: column
::: codewindow
``` r
modal_confirm <- modalDialog(
  "Are you sure you want to continue?",
  title = "Deleting files",
  footer = tagList(
    actionButton("cancel", "Cancel"),
    actionButton("ok", "Delete", class = "btn btn-danger")
  )
)


ui <- fluidPage(
  actionButton("delete", "Delete all files?")
)


server <- function(input, output, session) {
  observeEvent(input$delete, {
    ## en vez de desatar el evento borrar corre el dialogo
    showModal(modal_confirm)
  })
  
  observeEvent(input$ok, {
    showNotification("Files deleted")
    removeModal()
  })
  observeEvent(input$cancel, {
    removeModal()
  })
}

shinyApp(ui, server)
```
:::
::::

::: column
![](https://mastering-shiny.org/demos/action-feedback/dialog.png)
:::
::::::

## Bot√≥n de arrepentimiento {.smaller}

![](assets/cat-theme/turso-03.svg){.absolute top="100" right="100"
width="450" height="450"}

:::::: columns
:::: {.column width="50%"}
::: {.spacer style="height:50%;"}
A veces [confirmar acciones con un *‚Äú¬øest√°s seguro?‚Äù*]{.purple-text} no
sirve

Porque los usuarios se acostumbran a clickear [S√≠]{.blue-text}

Esta opci√≥n permite [deshacer]{.pink-text} luego de ejecutar la acci√≥n
(como pasa con los mails).

Para eso se puede utilizar `observeEvent()`, se puede llamar a
`runLater()` esperar X segundos y reci√©n realizar la acci√≥n o
eliminarla.
:::
::::

::: {.column width="50%"}
:::
::::::

## [Ejemplo]{.pink-text} de bot√≥n de arrepentimiento

:::::: columns
:::: column
::: codewindow
``` r
ui <- fluidPage(
  textAreaInput("message", 
    label = NULL, 
    placeholder = "What's happening?",
    rows = 3
  ),
  actionButton("tweet", "Tweet")
)

runLater <- function(action, seconds = 3) {
  observeEvent(
    invalidateLater(seconds * 1000), action, 
    ignoreInit = TRUE, 
    once = TRUE, 
    ignoreNULL = FALSE,
    autoDestroy = FALSE
  )
}

server <- function(input, output, session) {
  waiting <- NULL
  last_message <- NULL
  
  observeEvent(input$tweet, {
    notification <- glue::glue("Tweeted '{input$message}'")
    last_message <<- input$message
    updateTextAreaInput(session, "message", value = "")

    showNotification(
      notification,
      action = actionButton("undo", "Undo?"),
      duration = NULL,
      closeButton = FALSE,
      id = "tweeted",
      type = "warning"
    )

    waiting <<- runLater({
      cat("Actually sending tweet...\n")
      removeNotification("tweeted")
    })
  })
  
  observeEvent(input$undo, {
    waiting$destroy()
    showNotification("Tweet retracted", id = "tweeted")
    updateTextAreaInput(session, "message", value = last_message)
  })
}
```
:::
::::

::: column
![](imagenes/5.10.boton_arrepentimiento.gif){width="563"}
:::
::::::

#  {.theme-section2}

::: {.r-fit-text style="transform: translateY(-15rem);"}
¬°Muchas gracias!
:::
