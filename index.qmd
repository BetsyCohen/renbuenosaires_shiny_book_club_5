---
format:
  revealjs: 
    theme: [default, styles.scss]
    width: 1280
    height: 720
    include-after-body: 
      - "all-the-js-code.html"
    revealjs-plugins:
      - codewindow
echo: false
code-line-numbers: false
footer: "Realizado con el <a href='https://github.com/EmilHvitfeldt/talk-socalrug-hackathon-feature-engineering' target='_blank'>template de emilhvitfeldt</a> para el <a href='https://github.com/RLadies-BA/mastering-shiny' target='_blank'>Club de lectura Mastering Shiny</a>"
editor: 
  markdown: 
    wrap: 72
---

## User feedback {.theme-title .center}

### Mastering Shiny Book Club

Betsy Cohen & Ariana Bardauil

## Objetivos de este encuentro

::: {.speech .pink}
![](assets/cat-theme/profile-01.svg) Recapitular encuentros anteriores
:::

::: fragment
::: {.speech .purple .right}
Cap√≠tulo 8: User feedback ![](assets/cat-theme/profile-02.svg)
:::
:::

#  {.theme-section2}

::: {.r-fit-text style="transform: translateY(-15rem);"}
¬øQu√© vimos en los encuentros anteriores?
:::

# Encuentro 1 {.theme-section3}

Basic APP & Basic UI

## Cap√≠tulos 1 y 2: Basic APP & Basic UI

::: fragment
::: r-fit-text
Construimos nuestra

[primera aplicaci√≥n]{.pink-shadow}

en [shiny]{.blue-shadow}
:::
:::

## Estructura b√°sica

<br>

![](assets/cat-theme/head-01.svg){.absolute bottom="0" right="0"
width="150" height="150"}

::: columns
::: column
::: codewindow
``` r
library(shiny)

ui <- fluidPage(
  textInput("name", "¬øC√≥mo te llam√°s?"),
  textOutput("greeting")
)

server <- function(input, output, session) {
  output$greeting <- renderText({
    paste0("Hola ", input$name, "!")
  })
}

shinyApp(ui, server)
```
:::
:::

::: column
::: incremental
-   **ui** define la interfaz de usuario.
-   **server** define la l√≥gica del servidor (c√≥mo responde la app).
-   **shinyApp(ui, server)** renderiza la app.
:::
:::
:::

## Estructura b√°sica

![](assets/cat-theme/head-07.svg){.absolute top="-50" right="300"
width="150" height="150"}

<br>

![](imagenes/1.01.basic_app.png){fig-align="center" width="913"}

<!-- ## UI basica -->

<!-- ![](assets/cat-theme/head-24.svg){.absolute top="-50" right="300"} -->

<!-- ::: {.spacer style="height:70%;"} -->

<!-- [fluidPage()]{.brown-text} organiza los componentes en una p√°gina -->

<!-- adaptable. -->

<!-- Vimos algunas [entradas o inputs]{.pink-text} como `textInput()` (texto -->

<!-- libre), `numericInput()` (n√∫meros), `actionButton()` (botones) y -->

<!-- `sliderInput()`. -->

<!-- Y, [salidas (outputs)]{.pink-text} como `textOutput()` que permiten la -->

<!-- l√≥gica reactiva desde el `server()` usando `render...` o `eventReactive` -->

<!-- (para los botones). -->

<!-- ::: -->

# Encuentro 2 {.theme-section4}

Basic reactivity

## Basic reactivity

![](assets/cat-theme/head-30.svg){.absolute top="-50" right="300"
width="120" height="120"} ![](assets/cat-theme/head-31.svg){.absolute
top="-50" right="120" width="150" height="120"}

![](imagenes/2.01.reactividad.png){fig-align="center" width="723"}

![](imagenes/2.02.users.png){fig-align="center" width="516"}

## Programaci√≥n declarativa

![](assets/cat-theme/head-07.svg){.absolute top="-50" right="300"
width="150" height="150"} ![](assets/cat-theme/head-08.svg){.absolute
top="-50" right="150" width="150" height="150"}

<br>

Shiny usa [programaci√≥n declarativa]{.pink-text}

> No le indicamos qu√© hacer sino qu√© queremos lograr.

[Son aplicaciones perezosas]{.pink-text}: solo actualizan los outputs
visibles, y solo cuando es necesario.

::: columns
::: {.column width="20%"}
![](https://cdn.pixabay.com/animation/2023/04/28/18/34/18-34-10-554_512.gif){fig-align="center"
width="128" height="109"}
:::

::: {.column width="80%"}
Si no est√° vinculado a una salida visible el [c√≥digo puede no ejecutarse
nunca]{.brown-text}
:::
:::

# Encuentro 3 {.theme-section5}

Workflow

## Control de flujo & debuggeo

![](assets/cat-theme/turso-03.svg){.absolute top="150" right="100"
width="450" height="450"}

¬øQu√© puedo usar para saber [qu√© le pasa a mi app]{.blue-text} ?

::: columns
::: {.column width="50%"}
::: codewindow
``` r
print() cat()
```
:::

::: codewindow
``` r
# Abre una app interactiva
eventReactive(input$go, {
  browser() 
  input$a + input$b
})
```
:::

::: codewindow
``` r
# Al principio del script
reactlog::reactlog_enable()
# Luego de ejecutar la APP y cerrarla:
shiny::reactlogShow()
```
:::
:::

::: {.column width="50%"}
:::
:::

# Encuentro 4 {.theme-section1}

Layout, themes, HTML

## Layouts (dise√±os de p√°gina)

![](assets/cat-theme/turso-02.svg){.absolute top="50" right="50"
width="450" height="450"}

::: {.spacer style="height:70%;"}
[P√°gina √∫nica]{.brown-text}

`fluidPage()`, `fixedPage()` ,`fillPag()` (p√°gina)

`sidebarLayout()` , `fluidRow()` , `column()` (dise√±o)

[Varias p√°ginas]{.pink-text}

`navbarPage()` (p√°gina)

`tabsetPanel()`, `tabPanel()` , `navlistPanel()` ,`navbarMenu()`
(dise√±o)
:::

## Aplicaci√≥n de estilos

::: columns
::: {.column width="50%"}
**HTML**

::: codewindow
``` r
<span style="color:hotpink;">texto de prueba</span>
```
:::

**CSS**

::: codewindow
``` r
.pink-text {
  color: darken($theme-pink, 10%);
  font-weight: bold;
}
```
:::

[texto de prueba]{.pink-text}
:::

::: {.column width="50%"}
**THEME**

::: codewindow
``` r
library(shiny)
library(bslib)

ui <- fluidPage(
  theme = bs_theme(bootswatch = "minty"),
  h2("App con tema Minty"),
  sliderInput("x", "Eleg√≠ un n√∫mero", 1, 100, 50),
  textOutput("valor")
)

server <- function(input, output, session) {
  output$valor <- renderText({
    paste("N√∫mero:", input$x)
  })
}
```
:::
:::
:::

# Encuentro 5 {.theme-section6}

[HOY HOY HOY HOY HOY]{.brown-text}

#  {.theme-section7}

::: {.r-fit-text style="transform: translateY(-15rem);"}
[User feedback]{.brown-shadow}
:::

## El UX no son los padres

::: {.spacer style="height:70%;"}
Experiencia de usuario

Interactuar de manera visual a diferentes situaciones

Pedagog√≠a refuerzo con est√≠mulo visual para aprendizaje
:::
  
::: notes
Un concepto central en nuestra app es la **experiencia de usabilidad** o
UX

No solo se trata de que todo se vea bonito (como vimos en el capitulo de
Themes) sino tambi√©n de que interactuar o dar un feedback de manera
visual ante las diferentes situaciones de interacci√≥n que plantea
nuestra app.

En shinny de manera autom√°tica, pero hay otros que podemos agregar que
refuerzan este est√≠mulo
:::

## Tipos de feedback

El cap√≠tulo se recorren 4 posibles formas de feedback usando el ayud√≠n de
`shinyFeedback` y `waiter`.

:::: columns
::: {.column width="70%"}
-   üõëÔ∏è Validaci√≥n 
-   ‚ö†  Notificaci√≥n 
-   ‚åõ Barras de progreso 
-   üëå Di√°logos de confirmaci√≥n 
-   üîô Botones de deshacer 
:::

::: {.column width="30%"}
![](imagenes/shinyfeedback_waiter_hexs.png)
:::
::::


## Validar una entrada {.smaller}

::: notes
Pensar en c√≥mo el usuario podr√≠a usar mal tu aplicaci√≥n te permite
proporcionar mensajes informativos en la interfaz de usuario, en lugar
de permitir que los errores se filtren en el c√≥digo de R y generen
errores no informativos.

Un primer paso es validar el tipo de entrada cosa que podemos hacer con
el paquete shinyFeedback
:::

::: columns
::: column

```{r}
#| code-line-numbers: "4,12-15"
#| eval: false
#| echo: true

library(shiny)

ui <- fluidPage(
  shinyFeedback::useShinyFeedback(),
  numericInput("n", "n", value = 10),
  textOutput("half")
)

server <- function(input, output, session) {
  half <- reactive({
    even <- input$n %% 2 == 0
    shinyFeedback::feedbackWarning(
      inputId = "n", 
      show = !even,
      text = "Por favor pone un n√∫mero par")
    input$n / 2    
  })
  
  output$half <- renderText(half())
}

shinyApp(ui, server)

```

:::


::: column
::: incremental 

-   Agregamos `useShinyFeedback()` en el ui.
-   En el usamos alguna de las funciones de retroalimentaci√≥n
    `feedback()`, `feedbackWarning()`, `feedbackDanger()`y
    `feedbackSuccess()`
-   Todas tienen tres argumentos obligatorios (inputId, show, text) y de
    manera optativa podemos poner: color y icon
:::
:::
:::

## Validar una entrada

::: columns
::: column
::: codewindow
``` r
library(shiny)

ui <- fluidPage(
  shinyFeedback::useShinyFeedback(),
  numericInput("n", "n", value = 10),
  textOutput("half")
)

server <- function(input, output, session) {
  half <- reactive({
    even <- input$n %% 2 == 0
    shinyFeedback::feedbackWarning("n", !even, "Por favor pone un n√∫mero par")
    input$n / 2    
  })
  
  output$half <- renderText(half())
}

shinyApp(ui, server)
```
:::
:::

::: column
![](imagenes/5.01.shinyfeedback_sin_rec.png)
:::
:::

## Pausar la ejecuci√≥n bajo requisitos {.smaller}

A veces necesitamos una forma de pausar la ejecuci√≥n para que no ocurra nada hasta que se cumplan ciertas condiciones en nuestro `reactive{}`.
La funci√≥n `req()` nos permite agregar requisitos para la ejecucci√≥n dentro del server
Por ej. en este caso podemos poner como requisito que no muestre el resultado err√≥neo

::: columns
::: column

```{r}
#| code-line-numbers: "16"
#| eval: false
#| echo: true

library(shiny)

ui <- fluidPage(
  shinyFeedback::useShinyFeedback(),
  numericInput("n", "n", value = 10),
  textOutput("half")
)

server <- function(input, output, session) {
  half <- reactive({
    even <- input$n %% 2 == 0
    shinyFeedback::feedbackWarning(
      inputId = "n", 
      show = !even,
      text = "Por favor pone un n√∫mero par")
    req(even)
    input$n / 2    
  })
  
  output$half <- renderText(half())
}

shinyApp(ui, server)

```
:::

::: column
![](imagenes/5.02.shinyfeedback_con_rec.png)
:::
:::





## Pausar la ejecuci√≥n bajo requisitos {.smaller}
Y a veces tenemos m√°s de una condici√≥n o requisito que queremos freezar y conviene esperar a que el usuario termnine de hacer algo. Por ej. en este caso necesitamos que termine de elegir el idioma (`selectInput()`) y ponga su nombre (`textInput()`) como requisito para que se ejecute el **greetings** en el `paste0()`

:::: columns
::: column
::: codewindow
```r
ui <- fluidPage(
  selectInput("language", "Language", choices = c("", "English", "Maori")),
  textInput("name", "Name"),
  textOutput("greeting")
)

server <- function(input, output, session) {
  greetings <- c(
    English = "Hello", 
    Spanish = "Hola"
  )
  output$greeting <- renderText({
    req(input$language, input$name)
    paste0(greetings[[input$language]], " ", input$name, "!")
  })
}
```
:::
:::

::: column
![](imagenes/5.03.rec_multiple.png)
:::
::::

::: callout-note
### req() como declaraci√≥n l√≥gica per se
Tambi√©n se puede usar `req()` con su propia declaraci√≥n l√≥gica si es necesario. Por ejemplo, req(input$a > 0)permitir√° que el c√°lculo contin√∫e cuando asea mayor que 0.
:::

## Cobinando req() y shinyFeedback {.smaller}

Y tambi√©n podemos combinar ambas cosas como en este caso (que retoma el ejemplo de app del capitulo 1 se seleccion de dataset segun el nombre) queremos continuar con el c√°lculo si el usuario ha ingresado un valor, por lo que lo hacemos req(), chequeamos si el nombre existe y sino no existe tira un warning avisando.

:::: columns

::: column
::: codewindow
``` r
server <- function(input, output, session) {
  data <- reactive({
    req(input$dataset)
    
    exists <- exists(input$dataset, "package:datasets")
    shinyFeedback::feedbackDanger("dataset", !exists, "Dataset desconocido")
    req(exists, cancelOutput = TRUE)

    get(input$dataset, "package:datasets")
  })
  
  output$data <- renderTable({
    head(data())
  })
}
```
:::
:::

::: column
![](imagenes/5.04.validacion_junto_con_rec.png)
:::

::::

## Validar multiples entradas y salidas con validate() {.smaller}

La funci√≥n integrada de shiny `validate()` nos va a permitir controlar m√∫ltiples entradas **y** tirar el mensaje.

El siguiente c√≥digo muestra un ejemplo sencillo donde no queremos registrar ni calcular la ra√≠z cuadrada de valores negativos en x. 

::: columns

::: column
::: codewindow
``` r
ui <- fluidPage(
  numericInput("x", "x", value = 0),
  selectInput("trans", "transformation", 
    choices = c("square", "log", "square-root")
  ),
  textOutput("out")
)

server <- function(input, output, session) {
  output$out <- renderText({
    if (input$x < 0 && input$trans %in% c("log", "square-root")) {
      validate("El valor que elegiste para tu x no admite ser negativo para aplicarle este c√°lculo")
    }
    
    switch(input$trans,
      square = input$x ^ 2,
      "square-root" = sqrt(input$x),
      log = log(input$x)
    )
  })
}
```
:::
:::

::: column
![](imagenes/5.05.validacion_con_validate.png)
:::

:::


## Cual ser√≠a la diferencia entre `validate()` y `req()` {.smaller}

| Funci√≥n      | ¬øQu√© hace?                                                                    | ¬øD√≥nde se usa?                     | ¬øQu√© muestra si falla?                |
| ------------ | ----------------------------------------------------------------------------- | ---------------------------------- | ------------------------------------- |
| `req()`      | Verifica que un valor exista o cumpla una condici√≥n m√≠nima                    | Cualquier parte del servidor       | **Nada** (el output queda en blanco)  |
| `validate()` | Verifica una condici√≥n l√≥gica y **muestra un mensaje de error personalizado** | Solo dentro de `render*()` outputs | El **mensaje de error** que le pongas |


## Notificaciones

Las notificaciones las vamos a ir viendo apiladas en la parte inferior derecha de la app.

Tipos de notificaci√≥n:

-   **transitoria**: desaparece autom√°ticamente despu√©s de un per√≠odo de tiempo fijo.
-   **del proceso**: cuando se inicia un proceso y eliminarla cuando el proceso finaliza.
-   **progresivas**: actualizar una sola notificaci√≥n con actualizaciones progresivas

Todas las vamos a trabajar con la funci√≥n `showNotification()`


## Notificaci√≥n transitoria

-   La forma m√°s sencilla de usarlo showNotification() es llamarlo con un solo argumento: el mensaje que queres mostrar.
-   De forma predeterminada, el mensaje desaparecer√° despu√©s de 5 segundos y podemos anular esto con la opci√≥n [ duration] o el user puede cancelarlo haciendo click en la cruceita de cerrar
-   Si desea que la notificaci√≥n sea m√°s visible, se puede configurar el argumento type de modo que tome el css del theme para "message", "warning" o "error"

::: columns
::: column

::: codewindow
```r
library(shiny)

ui <- fluidPage(
  textInput("nombre", "Nombre"),
  actionButton("enviar", "Enviar")
)

server <- function(input, output, session) {
  observeEvent(input$enviar, {
    if (input$nombre == "") {
      showNotification("Por favor ingres√° un nombre", type = "error")
    } else {
      showNotification("Formulario enviado correctamente", type = "message")
    }
  })
}

shinyApp(ui, server)

```
:::
:::

::: column

![](imagenes/5.06.Notificacion_transitoria.png)
:::
:::

## Notificaci√≥n del proceso

::: columns
::: column
::: codewindow
```r
library(shiny)

ui <- fluidPage(
  actionButton("procesar", "Procesar datos")
)

server <- function(input, output, session) {
  observeEvent(input$procesar, {
    # Mostrar notificaci√≥n persistente mientras se procesa
    id <- showNotification("Procesando datos...", duration = NULL, closeButton = FALSE, type = "message")
    
    # Simular un proceso lento
    Sys.sleep(3)
    
    # Eliminar la notificaci√≥n al terminar
    removeNotification(id)
    
    # Mostrar notificaci√≥n de √©xito que desaparece sola
    showNotification("¬°Datos procesados correctamente!", type = "message")
  })
}

shinyApp(ui, server)
```

:::
:::
::: column
![](imagenes/5.06.Notificacion_proceso.gif)
:::
:::


## Notificaci√≥n de actalizaci√≥n progresiva

Pensar ejemplo para este

## Barras de progreso 

En el libro vemos dos soluciones a las barras de progreso una nativa de shiny y otra con el paquete `waiter{}`

Adicionalmente existe la librer√≠a progress

Para ambos casos hay que dividir la tarea principal en un n√∫mero determinado de partes peque√±as que tomen aproximadamente el mismo tiempo. 

## Barras de progreso con shiny

Para crear una barra de progreso con Shiny, necesitas usar withProgress()y incProgress()

El primer argumento de incProgress()es la cantidad que se incrementar√° en la barra de progreso. Por defecto, la barra de progreso empieza en 0 y termina en 1, por lo que el incremento en 1 dividido por el n√∫mero de pasos garantizar√° que la barra de progreso est√© completa al final del bucle.

::: codewindow
```r
ui <- fluidPage(
  numericInput("steps", "How many steps?", 10),
  actionButton("go", "go"),
  textOutput("result")
)

server <- function(input, output, session) {
  data <- eventReactive(input$go, {
    withProgress(message = "Computing random number", {
      for (i in seq_len(input$steps)) {
        Sys.sleep(0.5)
        incProgress(1 / input$steps)
      }
      runif(1)
    })
  })
  
  output$result <- renderText(round(data(), 2))
}
```
:::

## Barras de progreso con waiter


## Spinners o circulito




